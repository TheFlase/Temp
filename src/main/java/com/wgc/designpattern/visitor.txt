参考：
http://www.cnblogs.com/chenssy/


1.访问者模式
2.模板方法模式
3.策略模式
4.观察者模式
5.责任链模式


一、访问者模式

访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。
为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式，这就是访问者模式的模式动机。







二、模板方法模式

（1）模式优缺点
优点
1、模板方法模式在定义了一组算法，将具体的实现交由子类负责。
2、模板方法模式是一种代码复用的基本技术。
3、模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”。

缺点
每一个不同的实现都需要一个子类来实现，导致类的个数增加，是的系统更加庞大。

（2）使用场景
1、一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
2、各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
3、控制子类的扩展。

（3）模式总结
1、模板方法模式定义了算法的步骤，将这些步骤的实现延迟到了子类。
2、模板方法模式为我们提供了一种代码复用的重要技巧。
3、模板方法模式的抽象类可以定义抽象方法、具体方法和钩子。
4、为了防止子类改变算法的实现步骤，我们可以将模板方法声明为final。









三、策略模式
    策略模式是对算法进行封装，把算法的责任和算法本身进行分割开来，同时委派给不同的对象进行管理。
策略模式是将一个系列的算法封装到一系列的策略里面。
    其实对于算法的选择，策略模式并不关心，它只是对算法进行封装，至于算法什么时候什么地方使用什么算法都是客户所决定的，
这样就提高了系统的灵活性，但同时也增加了客户的负担，因为客户需要清楚知道选择什么样的算法对自己最有利，这就需要客户对每一个算法都清楚知道他们的区别。

（1）优缺点

优点
​1、策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
2、策略模式提供了可以替换继承关系的办法。
​3、使用策略模式可以避免使用多重条件转移语句。

缺点
​1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
2、策略模式将造成产生很多策略类，

（2）使用场景
​1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
2、一个系统需要动态地在几种算法中选择一种。
3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。










四、观察者模式
    何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。
    在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，
所以么可以根据需要增加和删除观察者，使得系统更易于扩展。
    观察者模式又称为发布-订阅模式。

    Subject：目标。他把所有对观察者对象的引用保存在一个聚集里，每一个主题都可以有多个观察者。
    Observer：观察者。为所有的具体观察者定义一个接口，在得到主题的通知时能够及时的更新自己。
    ConcreteSubject：具体主题。将有关状态存入具体观察者对象。在具体主题发生改变时，给所有的观察者发出通知。
    ConcreteObserver:具体观察者。实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态相协调。

（1）观察者模式的优缺点
    优点：
    1、当两个对象之间送耦合，他们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间送耦合。主题所知道只是一个具体的观察者列表，每一个具体观察者都符合一个抽象观察者的接口。主题并不认识任何一个具体的观察者，它只知道他们都有一个共同的接口。
    2、观察者模式支持“广播通信”。主题会向所有的观察者发出通知。
    3、观察者模式符合“开闭原则”的要求。

    缺点：
    1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
    2、 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进 行循环调用，可能导致系统崩溃。
    3、 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

（2）观察者模式的适用场所
    ​ 1、一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
    2、一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
    3、一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

（3）总结
    1、观察者模式定义了对象之间的一对多关系。多个观察者监听同一个被观察者，当该被观察者的状态发生改变时，会通知所有的观察者。
    2、观察者模式中包含四个角色。主题，它指被观察的对象。具体主题是主题子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者，将对观察主题的改变做出反应；具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。
    3、主题用一个共同的接口来更新观察者。
    4、观察者与被观察者之间用松耦合方式结合。
    5、有多个观察者时，不可以依赖特定的通知次序。
    6、使用观察者模式，可以从被观察者处推或者拉数据。



五、责任链模式

    避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，
直到有对象处理它为止，这就是职责链模式。
    在职责链模式中最关键的一点就是客户提交请求后，请求沿着链往下传递直到有一个处理者处理它，在这里客户无需关心它的请求是哪个处理者来处理，反正总有一个处理者会处理它的请求。
    在这里客户端和处理者都没有对方明确的信息，同时处理者也不知道职责链中的结构。所以职责链可以简化对象的相互连接，他们只需要保存一个指向其后续者的引用，而不需要保存所有候选者的引用。
    在职责链模式中我们可以随时随地的增加或者更改一个处理者，甚至可以更改处理者的顺序，增加了系统的灵活性。处理灵活性是增加了，但是有时候可能会导致一个请求无论如何也得不到处理，它会被放置在链末端，这个既是职责链的优点也是缺点。

    责任链三个角色：
    Handler: 抽象处理者。定义了一个处理请求的方法。所有的处理者都必须实现该抽象类。
    ConcreteHandler: 具体处理者。处理它所负责的请求，同时也可以访问它的后继者。如果它能够处理该请求则处理，否则将请求传递到它的后继者。
    Client: 客户类。

（1）优缺点
优点
​ 1、降低耦合度。它将请求的发送者和接受者解耦。
​ 2、简化了对象。使得对象不需要知道链的结构。
​ 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
​ 4、增加新的请求处理类很方便。

缺点
​ 1、不能保证请求一定被接收。
​ 2、系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。
​ 3、可能不容易观察运行时的特征，有碍于除错。

（2）模式适用场景
​ 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
​ 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
​ 3、可动态指定一组对象处理请求。

（3）总结
​ 1、职责链模式将请求的发送者和接受者解耦了。客户端不需要知道请求处理者的明确信息，甚至不需要知道链的结构，它只需要将请求进行发送即可。
​ 2、职责链模式能够非常方便的动态增加新职责或者删除职责。
​ 3、客户端发送的请求可能会得不到处理。
​ 4、处理者不需要知道链的结构，只需要明白他的后续者是谁就可以了。这样就简化了系统中的对象。



